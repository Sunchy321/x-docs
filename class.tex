%!TEX root = x.tex

\rSec0[class]{类}
\indextext{类}

\begin{bnf}{ClassDecl}
    ClassQual\bnfs \terminal{class} Identifier ClassBody
\end{bnf}

\begin{bnf}{ClassQual}
    \terminal{const}
\end{bnf}

\begin{bnf}{ClassBody}
    \terminal{\{} ClassMember\bnfs \terminal{\}}
\end{bnf}

\begin{bnf}{ClassMember}
    FieldDecl \br
    PropertyDecl \br
    FuncDecl \br
    TypeDecl \br
    ClassDecl \br
    EnumDecl \br
    ConceptDecl
\end{bnf}

\pnum
\term{类}描述内部不透明的类型。

\rSec1[class.member]{字段}
\indextext{类!字段}

\begin{bnf}{FieldDecl}
    FieldQual\bnfs BindKeyword Identifier TypeNotation Initializer\bnfq \terminal{;}
    FieldQual\bnfs BindKeyword Identifier Initializer \terminal{;}
\end{bnf}

\begin{bnf}{TypeNotation}
    \terminal{:} Type
\end{bnf}

\begin{bnf}{Initializer}
    \terminal{=} Expression
\end{bnf}

\pnum
类中的字段表示类的内部状态，其默认访问级别为\tcode{private}。使用\tcode{let}声明的表示不可变字段，使用\tcode{var}声明的表示可变字段。类字段可以显式指定类型，也可以通过初始值推导类型。

\rSec1[class.property]{属性}
\indextext{类!属性}

\begin{bnf}{PropertyDecl}
    PropertyQual\bnfs BindKeyword Identifier TypeNotation\bnfq Initializer\bnfq PropertyBody \terminal{;}
\end{bnf}

\begin{bnf}{PropertyQual}
    AccessQual
\end{bnf}

\begin{bnf}{PropertyBody}
    \terminal{\{} PropertyMember\bnfp \terminal{\}}
\end{bnf}

\begin{bnf}{PropertyMember}
    PropertyQual\bnfs PropertyKeyword PropertyBlockParam\bnfq Block \br
    PropertyQual\bnfs PropertyKeyword PropertyExprParam\bnfq \terminal{=>} Expression \terminal{;} \br
    PropertyQual\bnfs PropertyKeyword \terminal{;}
\end{bnf}

\begin{bnf}{PropertyKeyword}[\oneof]
    \terminal{get set willSet didSet}
\end{bnf}

\begin{bnf}{PropertyBlockParam}
    Identifier \br
    Identifier \terminal{,} Identifier
\end{bnf}

\begin{bnf}{PropertyExprParam}
    Identifier \br
    \terminal{(} Identifier \terminal{,} Identifier \terminal{)}
\end{bnf}

\pnum
类中还可以声明\term{属性}。属性是类对外暴露的接口，其默认访问级别为\tcode{public}。属性的定义至少需要包含一个访问器。访问器的块或表达式具有lambda作用域。

\pnum
属性的访问器可以以上下文关键字\tcode{get}、\tcode{set}、\tcode{willSet}或\tcode{didSet}开始。
\tcode{get}访问器不接受任何参数。
\tcode{set}访问器接受一个参数，其类型为该属性的类型。
\tcode{willSet}和\tcode{didSet}访问器可以接受一个或两个参数，其类型为属性的类型。

\pnum
如果\tcode{set}访问器不显式写出参数，则视为其具有lambda参数\tcode{\$value}。如果\tcode{willSet}或\tcode{didSet}不显式写出参数，则视为其具有lambda参数\tcode{\$oldValue}和\tcode{\$newValue}。

\pnum
如果属性$p$的声明中既不包含\tcode{get}也不包含\tcode{set}访问器，则视作该类具有字段$p'$，且具有访问器$\tcode{get}\mathrel{\tcode{=>}}\tcode{this.}p'$。如果该属性以\tcode{var}声明，则还视为该属性具有访问器$\tcode{set => this.}p'\tcode{ = \$value}$。
如果\tcode{get}或\tcode{set}访问器后直接跟分号，则视作以上述方式生成访问器，且另一个对应的访问器若存在则必须采用这种省略方式声明。

\pnum
使用\tcode{let}声明的属性不能包含\tcode{set}、\tcode{willSet}和\tcode{didSet}访问器。
在考虑自动生成的访问器之后，如果一个属性缺少\tcode{get}访问器，或一个\tcode{var}属性缺少\tcode{set}访问器，则这是一个编译错误。

\pnum
属性可以具有类型提示或初始化器。如果属性未按前文所述具有对应的字段，则不能具有初始化器。如果属性省略类型提示，则其类型将从\tcode{get}访问器中推导。如果它的\tcode{get}访问器是自动生成的，这是一个编译错误。

\pnum
当读取属性$p$时，会调用\tcode{get}访问器并将其返回值作为$p$的新值。

\pnum
当给属性$p$赋值时，首先将该值转换到属性的类型，令结果为$v$：

\begin{itemize}
    \item 如果属性具有\tcode{willSet}访问器：
    \begin{itemize}
        \item 如果它接受一个参数，将以$v$调用；
        \item 如果它接受两个参数，将以$p$（旧值）和$v$调用。
    \end{itemize}
    \item 以$v$调用属性的\tcode{set}访问器。
    \item 如果属性具有\tcode{didSet}访问器：
    \begin{itemize}
        \item 如果它接受一个参数，将以$p$（旧值）调用；
        \item 如果它接受两个参数，将以$p$和$v$调用。
    \end{itemize}
\end{itemize}

\rSec1[method]{方法}
\indextext{方法}

\pnum
类中的函数声明称作\term{方法}。方法隐含了一个\tcode{this}参数，其为调用该方法的对象。

\enterexample
\begin{codeblock}
class A {
    let x: int;
    func set(x: int) {
        std.io.print(this.x); // 无需显式this参数
    }
};

func set(this: A, x: int) {
    std.io.print(this.x); // 与上面相同
}

\end{codeblock}
\exitexample

\rSec2[method.lookup]{方法查找}
\indextext{方法!查找}

\pnum
