%!TEX root = x.tex

\rSec0[class]{类}
\indextext{类}

\begin{bnf}{ClassDecl}
    ClassQual\bnfs \terminal{class} Identifier ClassBody
\end{bnf}

\begin{bnf}{ClassQual}
    \terminal{const}
\end{bnf}

\begin{bnf}{ClassBody}
    \terminal{\{} ClassMember\bnfs \terminal{\}} \br
    TupleType \br
    \terminal{=} Type
\end{bnf}

\begin{bnf}{ClassMember}
    FieldDecl \br
    PropertyDecl \br
    FuncDecl \br
    TypeDecl \br
    ClassDecl \br
    EnumDecl \br
    TraitDecl
\end{bnf}

\pnum
\term{类}描述内部不透明的类型。

\pnum
类可以以显式指定其字段的方式声明，也可以在其后指定一个元组类型或普通类型。这种情况下，等价于以指定的类型构造了一个不透明类型。

\enterexample
\begin{codeblock}
class T = int;
type T = class int; // 与前者相同
\end{codeblock}
\exitexample

\rSec1[class.member]{字段}
\indextext{类!字段}

\begin{bnf}{FieldDecl}
    FieldQual\bnfs BindKeyword Identifier TypeNotation Initializer\bnfq \terminal{;}
    FieldQual\bnfs BindKeyword Identifier Initializer \terminal{;}
\end{bnf}

\begin{bnf}{TypeNotation}
    \terminal{:} Type
\end{bnf}

\begin{bnf}{Initializer}
    \terminal{=} Expression
\end{bnf}

\pnum
类中的字段表示类的内部状态，其默认访问级别为\tcode{private}。具有\tcode{mut}修饰的是可变字段。类字段可以显式指定类型，也可以通过初始值推导类型。

\rSec1[class.property]{属性}
\indextext{类!属性}

\begin{bnf}{PropertyDecl}
    PropertyQual\bnfs BindKeyword Identifier TypeNotation\bnfq Initializer\bnfq PropertyBody \terminal{;} \br
    PropertyQual\bnfs BindKeyword Identifier TypeNotation\bnfq \terminal{=>} Expression \terminal{;}
\end{bnf}

\begin{bnf}{PropertyQual}
    AccessQual
\end{bnf}

\begin{bnf}{PropertyBody}
    \terminal{\{} PropertyMember\bnfp \terminal{\}}
\end{bnf}

\begin{bnf}{PropertyMember}
    PropertyQual\bnfs PropertyKeyword PropertyBlockParam\bnfq Block \br
    PropertyQual\bnfs PropertyKeyword PropertyExprParam\bnfq \terminal{=>} Expression \terminal{;} \br
    PropertyQual\bnfs PropertyKeyword \terminal{;}
\end{bnf}

\begin{bnf}{PropertyKeyword}[\oneof]
    \terminal{get set willSet didSet}
\end{bnf}

\begin{bnf}{PropertyBlockParam}
    Identifier \br
    Identifier \terminal{,} Identifier
\end{bnf}

\begin{bnf}{PropertyExprParam}
    Identifier \br
    \terminal{(} Identifier \terminal{,} Identifier \terminal{)}
\end{bnf}

\pnum
类中还可以声明\term{属性}。属性是类对外暴露的接口，其默认访问级别为\tcode{public}。属性的定义至少需要包含一个访问器。访问器的块或表达式具有lambda作用域。

\pnum
属性的访问器可以以上下文关键字\tcode{get}、\tcode{set}、\tcode{willSet}或\tcode{didSet}开始。
\tcode{get}访问器不接受任何参数。
\tcode{set}访问器接受一个参数，其类型为该属性的类型。
\tcode{willSet}和\tcode{didSet}访问器可以接受一个或两个参数，其类型为属性的类型。

\pnum
如果\tcode{set}访问器不显式写出参数，则视为其具有lambda参数\tcode{\$value}。如果\tcode{willSet}或\tcode{didSet}不显式写出参数，则视为其具有lambda参数\tcode{\$oldValue}和\tcode{\$newValue}。

\pnum
如果属性$p$的声明中既不包含\tcode{get}也不包含\tcode{set}访问器，则视作该类具有字段$p'$，且具有访问器$\tcode{get}\mathrel{\tcode{=>}}\tcode{this.}p'$。
如果该属性有\tcode{mut}修饰，则还视为该属性具有访问器$\tcode{set => this.}p'\tcode{ = \$value}$。
如果\tcode{get}或\tcode{set}访问器后直接跟分号，则视作以上述方式生成访问器，且另一个对应的访问器若存在则必须采用这种省略方式声明。
如果属性以直接后跟$\mathrel{\tcode{=>}}e$的方式声明，则视作该属性具有访问器$\tcode{get} \mathrel{\tcode{=>}} e$。

\pnum
未使用\tcode{mut}声明的属性不能包含\tcode{set}、\tcode{willSet}和\tcode{didSet}访问器。
在考虑自动生成的访问器之后，如果一个属性缺少\tcode{get}访问器，或一个\tcode{mut}属性缺少\tcode{set}访问器，则这是一个编译错误。

\pnum
属性可以具有类型提示或初始化器。如果属性未按前文所述具有对应的字段，则不能具有初始化器。如果属性省略类型提示，则其类型将从\tcode{get}访问器中推导。如果它的\tcode{get}访问器是自动生成的，这是一个编译错误。

\pnum
当读取属性$p$时，会调用\tcode{get}访问器并将其返回值作为$p$的新值。

\pnum
当给属性$p$赋值时，首先将该值隐式转换到属性的类型，令结果为$v$：

\begin{itemize}
    \item 如果属性具有\tcode{willSet}访问器：
    \begin{itemize}
        \item 如果它接受一个参数，将以$v$调用；
        \item 如果它接受两个参数，将以$p$（旧值）和$v$调用。
    \end{itemize}
    \item 以$v$调用属性的\tcode{set}访问器。
    \item 如果属性具有\tcode{didSet}访问器：
    \begin{itemize}
        \item 如果它接受一个参数，将以$p$（旧值）调用；
        \item 如果它接受两个参数，将以$p$和$v$调用。
        \item 如果函数体内没有使用新值，则不会调用\tcode{get}访问器并使用第一种形式调用。
    \end{itemize}
\end{itemize}

\rSec1[method]{方法}
\indextext{方法}

\pnum
类中的函数声明称作\term{方法}。方法隐含了一个\tcode{this}参数，其为调用该方法的对象。

\pnum
如果类内方法显式指定了\tcode{this}参数，则它的类型必须是这个类。在这种情况下，可以省略\tcode{this}的类型，而仅包含修饰符。如果省略\tcode{this}参数，则\tcode{this}不包含任何修饰符。

\enterexample
\begin{codeblock}
class A {
    f() { } // \#1
    f(this: A) { } // 与\#1等价
    f(this: int) { } // 错误，类方法不能指定另外的\tcode{this}类型
    f(this: A mut) { } // \#2，可以修改\tcode{A}的成员
    f(this: mut) { } // 与\#2等价
}

f(this: A) { } // 可以，与\#1等价
f(this: int) { } // 可以，类外方法能任意指定\tcode{this}类型
\end{codeblock}
\exitexample

\rSec2[method.lookup]{方法查找}
\indextext{方法!查找}

\pnum

\rSec1[class.init]{构造器}
\indextext{类!构造器}

\pnum
构造器是函数名称为关键字\tcode{init}的方法。构造器可以接受任意类型的参数并且不返回值。

\pnum
在构造器内部可以修改\tcode{this}成员的值，即使\tcode{this}并未显式被标记为\tcode{mut}。
不能在成员被赋值之前使用它们的值，或者调用使用它们值的方法。这是一个编译错误。

\pnum
泛型类的构造器可以显式指定返回类型，这称为\tcode{参与推导的构造器}。这类构造器可以单独指定泛型参数。

\rSec1[class.deinit]{析构器}
\indextext{类!析构器}

\pnum
析构器是函数名称为关键字\tcode{deinit}的方法。析构器不接受任何非\tcode{this}参数且不返回值。不能在类外部定义析构器。析构器不能抛出异常。

\pnum
当一个类对象被销毁时，将会调用析构器。