%!TEX root = x.tex

\rSec0[decl]{声明}
\indextext{声明}

\begin{bnf}{Declaration}
    BlockDecl
\end{bnf}

\begin{bnf}{BlockDecl}
    Binding \br
    FuncDecl \br
    TypeDecl \br
    ClassDecl \br
    EnumDecl \br
    TraitDecl \br
    ImplDecl \br
    OperatorDecl \br
    MacroDecl \br
    QualifierDirective
\end{bnf}

\pnum
\term{声明}将名称插入当前作用域，或者使用特定的程序结构实现程序功能。声明在插入名称时也可能\term{定义}了该名称对应的程序项。

\rSec1[decl.type]{类型声明}
\indextext{声明!类型}

\begin{bnf}{TypeDecl}
    TypeQual\bnfs \terminal{type} Identifier TypeBody
\end{bnf}

\begin{bnf}{TypeDeclName}
    Identifier \br
    \terminal{self}
\end{bnf}

\begin{bnf}{TypeQual}
    \terminal{const}
\end{bnf}

\begin{bnf}{TypeBody}
    StructType \br
    TupleType \br
    \terminal{=} Type
\end{bnf}

\pnum
类型声明用于为类型创建别名。在类型声明之后，可以使用该名称代表所关联的类型。

\rSec1[decl.class]{类声明}
\indextext{声明!类}

\begin{bnf}{ClassDecl}
    ClassQual\bnfs \terminal{class} Identifier ClassBody
\end{bnf}

\begin{bnf}{ClassQual}
    \terminal{const}
\end{bnf}

\begin{bnf}{ClassBody}
    StructType \br
    TupleType \br
    \terminal{=} Type
\end{bnf}

\pnum
类声明创建不透明类型。\tcode{class $C$ $B$}等价于\tcode{type $C$ = class $B$}。参见~\ref{type.opaque}。

\rSec1[qual.dir]{限定符指令}
\indextext{限定符指令}

\begin{bnf}{QualifierDirective}
    DirectiveQualifiers \terminal{::}
\end{bnf}

\begin{bnf}{DirectiveQualifiers}
    DirectiveQualifier\bnfp
\end{bnf}

\begin{bnf}{DirectiveQualifier}
    AccessQualifier
\end{bnf}

\pnum
可以使用限定符后跟\tcode{::}的方式为多个声明指定限定符。直到下一个限定符指令或该声明作用域结束为止，所有出现的声明都会受所指定的修饰符修饰。忽略无效的限定符。

\enterexample
\begin{codeblock}
public:: // 后面所有声明都是\tcode{public}的
type A = int;
const let size = 0;
\end{codeblock}