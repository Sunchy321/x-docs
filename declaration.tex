%!TEX root = x.tex

\rSec0[decl]{声明}
\indextext{声明}

\begin{bnf}{Declaration}
    BlockDecl
\end{bnf}

\begin{bnf}{BlockDecl}
    FuncDecl \br
    TypeDecl \br
    ClassDecl \br
    EnumDecl \br
    TraitDecl \br
    QualifierDirective
\end{bnf}

\rSec1[decl.type]{类型声明}
\indextext{声明!类型}

\begin{bnf}{TypeDecl}
    TypeQual\bnfs \terminal{type} Identifier TypeBody
\end{bnf}

\begin{bnf}{TypeDeclName}
    Identifier \br
    \terminal{self}
\end{bnf}

\begin{bnf}{TypeQual}
    \terminal{const}
\end{bnf}

\begin{bnf}{TypeBody}
    StructType \br
    TupleType \br
    \terminal{=} Type
\end{bnf}

\pnum
类型声明用于为类型创建别名。

\rSec1[decl.class]{类声明}
\indextext{声明!类}

\begin{bnf}{ClassDecl}
    ClassQual\bnfs \terminal{class} Identifier ClassBody
\end{bnf}

\begin{bnf}{ClassQual}
    \terminal{const}
\end{bnf}

\begin{bnf}{ClassBody}
    StructType \br
    TupleType \br
    \terminal{=} Type
\end{bnf}

\pnum
类声明创建不透明类型。$\tcode{class }C\ B$等价于$\tcode{type }C\tcode{ = class }B$。

\rSec1[qual.dir]{限定符指令}
\indextext{限定符指令}

\begin{bnf}{QualifierDirective}
    DirectiveQualifiers \terminal{::}
\end{bnf}

\begin{bnf}{DirectiveQualifiers}
    DirectiveQualifier\bnfp
\end{bnf}

\begin{bnf}{DirectiveQualifier}
    AccessQualifier
\end{bnf}

\pnum
可以使用限定符后跟\tcode{::}的方式为多个声明指定限定符。直到下一个限定符指令或该声明作用域结束为止，所有出现的声明都会受所指定的修饰符修饰。忽略无效的限定符。

\enterexample
\begin{codeblock}
public:: // 后面所有声明都是\tcode{public}的
type A = int;
const let size = 0;
\end{codeblock}