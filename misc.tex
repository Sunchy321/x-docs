%!TEX root = x.tex

\rSec0[core.misc]{杂项}

\rSec1[core.type]{类型}

\pnum
本节包含了若干类型，它们均为语言内建，但并不是单个关键字。

\indexlibrary{\idxcode{Symbol}}
\begin{itemdecl}
type Symbol = __intrinsic;
\end{itemdecl}

\pnum
\tcode{Symbol}是所有符号字面量的公共类型。它只能通过内建的符号字面量来获得值。

\rSec1[core.order]{序}

\indexlibrary{\idxcode{Order}}
\begin{itemdecl}
enum Order {
    less,
    equal,
    greater
}
\end{itemdecl}

\pnum
\tcode{Order}定义了序关系。它是内建\tcode{cmp}运算符的返回值。自定义类型可以通过实现\tcode{cmp}运算符来支持序关系，参见~\ref{op.over.cmp}。

\pnum
\tcode{.less}代表左操作数小于右操作数。\tcode{.equal}代表左操作数等于右操作数。\tcode{.greater}代表左操作数大于右操作数。

\pnum
\tcode{cmp}也可以返回\tcode{Order?}。如果返回值为\tcode{nil}，则代表两个操作数之间没有序关系。

\rSec1[core.range]{范围}

\indexlibrary{\idxcode{Range}}
\begin{itemdecl}
class Range<T, dyn S: T, dyn E: T>;
\end{itemdecl}

\indexlibrary{\idxcode{ClosedRange}}
\begin{itemdecl}
class ClosedRange<T, dyn S: T, dyn E: T>;
\end{itemdecl}

\pnum
\tcode{Range}表示左闭右开区间。它是内建\tcode{..}的结果类型。

\pnum
\tcode{ClosedRange}表示闭区间。它是内建\tcode{..=}的结果类型。

\rSec2[core.range.init]{构造器}

\indexlibrary{\idxcode{Range}!\idxcode{init}}
\begin{itemdecl}
func init<T, dyn S: T, dyn E: T>(start: T, end: T) -> Range<T, dyn S, dyn E>;
\end{itemdecl}

\indexlibrary{\idxcode{ClosedRange}!\idxcode{init}}
\begin{itemdecl}
func init<T, dyn S: T, dyn E: T>(start: T, end: T) -> ClosedRange<T, dyn S, dyn E>;
\end{itemdecl}

\pnum
\tcode{Range}和\tcode{ClosedRange}可以使用两个参数\tcode{start}与\tcode{end}构造，分别表示开头与结尾。如果\tcode{start > end}则会抛出\tcode{.InvalidBounds}。

\rSec2[core.range.impl]{实现}

\begin{itemdecl}
impl<T, dyn S, dyn E> Range<T, dyn S, dyn E> : Sequence<T, dyn E - S> {
    type Iterator = RangeIterator<T>;
}
\end{itemdecl}

\begin{itemdecl}
impl<T, dyn S, dyn E> ClosedRange<T, dyn S, dyn E> : Sequence<T, dyn (E - S)+!> {
    type Iterator = ClosedRangeIterator<T>;
}
\end{itemdecl}

\pnum
\tcode{Range}和\tcode{ClosedRange}是序列，其迭代器类型是\tcode{RangeIterator}。

\rSec2[core.range.iter]{迭代器}

\indexlibrary{\idxcode{Range}!\idxcode{Iterator}}
\begin{itemdecl}
class RangeIterator<T>;
\end{itemdecl}

\indexlibrary{\idxcode{ClosedRange}!\idxcode{Iterator}}
\begin{itemdecl}
class ClosedRangeIterator<T>;
\end{itemdecl}

\pnum
\tcode{RangeIterator}是\tcode{Range}的迭代器类型。

\pnum
\tcode{ClosedRangeIterator}是\tcode{ClosedRange}的迭代器类型。

\rSec1[core.error]{错误处理}

\rSec2[core.panic]{\tcode{panic}}

\indexlibrary{\idxcode{panic}}
\begin{itemdecl}
func panic(message = "") -> never;
\end{itemdecl}

\pnum
\tcode{panic}在程序遇到无法处理的错误时终止程序的执行。它会向标准错误流打印错误信息\tcode{message}，并析构当前线程的所有对象，然后终止程序的执行。

\pnum
如果\tcode{panic}在执行过程中再次调用了\tcode{panic}，则会直接终止程序的执行而略过任何对象的析构。

\rSec2[core.result]{\tcode{Result}}

\indexlibrary{\idxcode{Result}}
\begin{itemdecl}
enum Result<T, E is Error = any Error> {
    Ok(T),
    Error(E)
}
\end{itemdecl}

\rSec3[core.result.impl]{实现}

\indexlibrary{\idxcode{Result}!\idxcode{impl}}
\begin{itemdecl}
impl<T, E> Result<T, E> { /* ... */ }
\end{itemdecl}

\indexlibrary{\idxcode{Result}!\idxcode{unwrap}}
\begin{itemdecl}
let unwrap: T { get throw(E); }
\end{itemdecl}

\pnum
\tcode{unwrap}返回\tcode{Result}的值。如果\tcode{Result}是\tcode{Error}，则会抛出那个异常。

\indexlibrary{\idxcode{Result}!\idxcode{operator suffix?}}
\begin{itemdecl}
func operator suffix?(r: Result<T, E>) -> T?;
\end{itemdecl}

\pnum
\tcode{operator suffix?}将\tcode{Result}转换为可空类型。如果\tcode{Result}是\tcode{Error}，则返回\tcode{nil}。