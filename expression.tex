%!TEX root = x.tex

\rSec0[expr]{表达式}
\indextext{表达式}

\begin{bnf}{Expression}
    PrimaryExpr \br
    Operator Expression \br
    Expression Operator \br
    Expression Operator Expression
\end{bnf}

% \pnum
% \term{表达式}由\term{运算符}与操作数按照顺序组合在一起，它表示一个计算过程。运算符是若干标点符号的组合、一个标识符或是语言规定的特殊结构。运算符可以是前缀、后缀或者是中缀的，这决定了运算符与其操作数的结合方式。运算符组是运算符的集合，每一个运算符都属于某个运算符组。运算符组之间有一个弱偏序关系，决定了它们的\term{优先级}。完全由中缀运算符构成的运算符组有\term{结合性}：左结合的组每个运算符从左到右选择操作数；右结合的组从右到左；无结合的组两个运算符不能选择同一个操作数。

\pnum
\ref{expr.suffix} 到 \ref{expr.semi} 各节按照优先级从高到低依次对运算符组进行描述。若无特别说明，每一节描述一个运算符组。

% \pnum
% 解析表达式按照如下顺序：

% \begin{itemize}
% \item 构造基本表达式、运算符和 ID 表达式。
% \item 将 \tcode{.} 和后面的 ID 表达式结合为一个后缀运算符。
% \item 将每个重载为运算符的标识符\footnote{这里指本身作为 ID 表达式的而不是作为 ID 表达式的一部分的标识符。}替换为运算符。
% \item 对于每组连续的基本表达式，如果除了第一个以外都形如 \tcode{(...)}、\tcode{[...]} 或 \tcode{\{...\}}，将它们替换为后缀运算符；否则这是一个编译错误。\enternote 因为块也是基本表达式，它也会被替换为后缀运算符。然后如果有的话，它会与之前的函数调用运算符结合成一个函数调用运算符。\exitnote
% \item 确定每个运算符是前缀、后缀或中缀的。对于每组连续的运算符，如果存在一个运算符满足：
% \begin{itemize}
%     \item 它要么是 \tcode{;} 要么两边都有空白；
%     \item 它可以作为中缀运算符；
%     \item 它前面的所有运算符都可以作为后缀运算符；\enternote 由上文已经限定为前缀运算符的运算符在这里不能作为后缀运算符；反之亦然 \exitnote
%     \item 它后面的所有运算符都可以作为前缀运算符。
% \end{itemize}
% 那么这个运算符是中缀运算符，这个运算符之前的所有运算符是后缀运算符，这个运算符之后的所有运算符是前缀运算符。如果存在多于一个或者不存在这样的运算符，这是一个编译错误。
% \item 运算符按照优先级选择操作数。对于优先级最高（可能不止一个）的运算符组：
% \begin{itemize}
%     \item 每个运算符选择各自的操作数。如果不同的组之间选择了相同的操作数，这是一个编译错误。如果选择的表达式不是基本表达式也不是优先级高于这个运算符组的运算符构成的表达式，这是一个编译错误。
%     \item 如果这个组由前缀、中缀和后缀混合而成或是无结合的中缀运算符组，选择相同的操作数的运算符引发一个错误；
%     \item 如果这个组是前缀组或者是右结合的中缀组，每个运算符从右到左把自己和操作数替换为一个子表达式；
%     \item 如果这个组是后缀组或者是左结合的中缀组，每个运算符从左到右把自己和操作数替换为一个子表达式。
% \end{itemize}
% \item 如果最后仍然剩余大于一个子表达式，这是一个编译错误。
% \end{itemize}

$$ \mathrm{\rhd}: \mathcal{E} \times \Omega \rightarrow (\mathcal{V} \cup \mathcal{V}^\dag \cup \{\ast\}) \times \Omega $$

\indextext{求值}
\pnum
$\mathrm{e \rhd \omega}$ 称作\term{在环境 $\omega$ 下对 $e$ 求值}。设 $\mathrm{e \rhd \omega} = \langle v, \omega^\prime \rangle$。如果 $v \in \mathcal{V}$，称\term{求值正常结束}，$v$ 是 $e$ 的\term{值}；否则，称\term{求值以抛出$v$异常结束}。$v = \ast$ 意味着求值过程中程序终止了。若无特别说明，对表达式$e$的子表达式$e_0$求值以抛出$v$异常结束也会导致对$e$的求值以抛出$v$异常结束。

\pnum
$\omega$ 是求值之前的环境，$\omega^\prime$ 是求值之后的环境。如果 $\omega = \omega^\prime$，称 $e$ 是\term{无副作用}的；如果 $e$ 是无副作用的且 $v$ 与 $\omega$ 无关，称 $e$ 是\term{纯}的。

\pnum
下文的数学定义式中，$\coloneqq$ 右边的 $e$ 表示对 $e$ 求值之后的 $v$；$\otimes e$ 表示求值后的环境；$\rhd e$ 表示求值的结果。如果表达式是无副作用的，将 $\omega$ 部分省略。

\pnum
对含有子表达式的表达式求值时，总是先对其子表达式按出现次序从左到右求值。

\pnum
\term{丢弃表达式 $e$ 的结果}指，在决定 $e$ 的类型时，直接将它确定为 \tcode{never} 而跳过所有步骤；在对 $e$ 求值时，进行所有步骤，但是如果求值正常结束，丢弃最后的值。

\rSec1[expr.primary]{基本表达式}
\indextext{表达式!基本}

\begin{bnf}{PrimaryExpr}
    \terminal{(} Expression \terminal{)} \br
    LiteralExpression \br
    Identifier \br
    \terminal{this} \br
    \terminal{\$} \br
    StmtExpr \br
    LambdaParameter \br
    LambdaExpr \br
    DoExpr
    % NameofExpr \br TODO: nameof 宏
\end{bnf}

\pnum
表达式$\tcode{(}e\tcode{)}$等价于$e$，括号只作分组用途。\enternote 注意括号表达式不是一元元组。\exitnote

\rSec2[expr.lit]{字面量表达式}
\indextext{表达式!字面量}

\begin{bnf}{LiteralExpression}
    IntegerLiteral \br
    FloatingLiteral \br
    StringLiteral \br
    BooleanLiteral \br
    \terminal{nil} \br
    ArrayLiteral \br
    TupleLiteral \br
    ObjectLiteral \br
    DictLiteral
\end{bnf}

\begin{bnf}{ArrayLiteral}
    \terminal{[} ExprList\bnfq \terminal{]}
\end{bnf}

\begin{bnf}{TupleLiteral}
    \terminal{(} TupleExprList\bnfq \terminal{)}
\end{bnf}

\begin{bnf}{ExprList}
    ExprItem \br
    ExprList \terminal{,} ExprItem
\end{bnf}

\begin{bnf}{TupleExprList}
    ExprItem \terminal{,} ExprItem \br
    TupleExprList \terminal{,} ExprItem
\end{bnf}

\begin{bnf}{ExprItem}
    Expression \br
    \terminal{...} Expression
\end{bnf}

\begin{bnf}{ObjectLiteral}
    \terminal{\{} ObjectItems \terminal{\}}
\end{bnf}

\begin{bnf}{ObjectItems}
    ObjectItem \br
    ObjectItems \terminal{,} ObjectItem
\end{bnf}

\begin{bnf}{ObjectItem}
    Identifier \terminal{:} Expression \br
    Identifier \br
    \terminal{...} Expression
\end{bnf}

\begin{bnf}{DictLiteral}
    \terminal{\{|} DictItems\bnfq \terminal{|\}}
\end{bnf}

\begin{bnf}{DictItems}
    DictItem \br
    DictItems \terminal{,} DictItem
\end{bnf}

\begin{bnf}{DictItem}
    Expression \terminal{:} Expression \br
    \terminal{...} Expression
\end{bnf}

\pnum
字面量本身是基本表达式。整数字面量、浮点字面量、字符串字面量和布尔字面量的值分别参见\ref{literal.integer}、\ref{literal.floating}、\ref{literal.string}和\ref{literal.boolean}节的定义。

\pnum
\tcode{nil}的类型为$T\tcode{?}$，其中$T$为待推导的类型参数。

\pnum
数组字面量$\tcode{[}e_1\tcode{,}\ldots\tcode{,}e_n\tcode{]}$表示一个显式写出其各元素的数组值。其类型为$T\tcode{[]}$，其中$T$为各表达式的公共类型。如果其中包含形如$\tcode{...}e$的项，则视同将$e$的各元素显式插入在该位置。$e$必须实现\tcode{core.Sequence}。如果数组字面量不包含任何成员，则$T$是一个待推导的类型。

\pnum
元组字面量$\tcode{(}e_1\tcode{,}\ldots\tcode{,}e_n\tcode{)}$表示一个显式写出其各元素的元组值。其类型为$\tcode{(}T_1\tcode{,}\ldots\tcode{,}T_n\tcode{)}$，其中$T_i$为$e_i$的类型。如果其中包含形如$\tcode{...}e$的项，则视同将$e$的各元素显式插入在该位置。$e$必须也是一个元组。特别的，\tcode{()}的类型为\tcode{void}，是\tcode{void}的唯一值。

\pnum
对象字面量$\tcode{\{}k_1\tcode{:}e_1\tcode{,}\ldots\tcode{,}x_n\tcode{:}e_n\tcode{\}}$表示一个显式写出其各元素的对象值。其类型为$\tcode{\{}k_1\tcode{:}T_1\tcode{,}\ldots\tcode{,}x_n\tcode{:}T_n\tcode{\}}$，其中$T_i$为$e_i$的类型。如果其中包含形如$\tcode{...}e$的项，则视同将$e$的各成员以相同标签显式插入在该位置。$e$必须是对象类型。\enternote 对象字面量必须至少包含一个键值对。\tcode{\{\}}将被解析为一个块。 \exitnote

\pnum
对象字面量$\tcode{\{}e\tcode{\}}$是$\tcode{\{}e\tcode{:}e\tcode{\}}$的简写。$e$必须是一个标识符。

\pnum
字典字面量$\tcode{\{|}k_1\tcode{:} v_1\tcode{,} k_2\tcode{:} v_2\tcode{,} \ldots\tcode{,} k_n\tcode{:} v_n\tcode{|\}}$表示一个显式写出其各元素的字典值。其类型为$T\tcode{[}K\tcode{]}$，其中$T$为各$v_i$的类型，$K$为各$k_i$的公共类型。如果其中包含形如$\tcode{...}e$的项，则视同将$e$的各元素对显式插入在该位置。$e$必须是字典类型。如果字典字面量不包含任何类型，则$T$和$K$是待推导的类型。

\rSec2[expr.this]{\tcode{this}}
\indextext{表达式!this}

\pnum
表达式\tcode{this}在类方法或扩展方法中表示当前方法的调用者。如果没有在参数中显式指定\tcode{this}的类型，则其类型为\tcode{self}。

\rSec2[expr.dollar]{\tcode{\$}}
\indextext{表达式!\$}

\pnum
表达式\tcode{\$}只能在序列作用域（\ref{scope.sequence}）中使用。如果当前序列为$s$，则\tcode{\$}等价于$s\tcode{.size}$。
该$s$必须实现了\tcode{core.Sequence}。在其他位置使用\tcode{\$}是一个编译错误。

\rSec2[expr.stmt]{语句表达式}
\indextext{表达式!语句}

\begin{bnf}{StmtExpr}
    Block \br
    IfExpr \br
    MatchStatement \br
    \terminal{break} \br
    \terminal{continue} \br
    \terminal{return} Expression\bnfq \br
    \terminal{throw} Expression\bnfq
\end{bnf}

\begin{bnf}{IfExpr}
    IfStatement \br
    \terminal{if} Condition \terminal{then} Expression \br
    \terminal{if} Condition \terminal{then} Expression \terminal{else} Expression
\end{bnf}

\pnum
部分语句也有对应的表达式。

\pnum
块表达式的值是其末尾表达式的值。如果该表达式被省略，其类型为\tcode{void}。

\pnum
\tcode{if}表达式的类型是其两个分支表达式的公共类型。如果\tcode{else}分支被省略，则视为\tcode{void}。其值为最终执行的那个分支的值。只有一个分支会被求值。

\pnum
\tcode{match}表达式的类型为其所有分支的公共类型，值为最终匹配成功的分支的值。只有一个分支会被求值。

\pnum
\tcode{break}、\tcode{continue}、\tcode{return}和\tcode{throw}表达式的语义与其对应的语句的语义相同，类型为\tcode{never}。

\rSec2[expr.lambda]{Lambda表达式}
\indextext{表达式!Lambda}

\begin{bnf}{LambdaExpr}
    FuncQual\bnfs LambdaParameter ReturnType\bnfs \terminal{=>} LambdaBody
\end{bnf}

\begin{bnf}{LambdaParameter}
    ParamDecl
\end{bnf}

\begin{bnf}{LambdaBody}
    Expression
\end{bnf}

\rSec3[expr.lambda.param]{Lambda参数}

\begin{bnf}{LambdaParameter}
    \terminal{\$} Digit\bnfp \br
    \terminal{\$} Identifier
\end{bnf}

\pnum
Lambda参数只能在lambda作用域（\ref{scope.lambda}）中使用，用于引用匿名参数。其类型是待推导的。
不在lambda作用域中使用lambda参数，或在显式指定参数的lambda表达式中使用lambda参数，是一个编译错误。

\pnum
$\tcode{\$}$后跟数字$i$指代第$i$个参数。$\tcode{\$}$后跟标识符$n$指代具名参数$n$。

\rSec3[expr.do]{\tcode{do}表达式}
\indextext{表达式!do}

\begin{bnf}{DoExpr}
    \terminal{do} Block \br
    \terminal{do} \terminal{!} Block
\end{bnf}

\pnum
\tcode{do}后跟一个块创建一个没有显式指定参数的lambda表达式。\tcode{do!}后跟一个块创建一个无参的lambda表达式并立即调用它，将其值作为整个表达式的值。

\enterexample
\begin{codeblock}
let arr = [1, 2, 3];

let first1 = arr.first { $0 > 2 }; // 获取第一个满足条件的元素

let firstFinder = do {
    for let v : $0 {
        if v > 2 { return v; }
    }
    nil
};

let first2 = firstFinder(arr); // 与上面等价

let first3 = do! {
    for let v : arr {
        if v > 2 { return v; }
    }
    nil
}; // 与上面等价

\end{codeblock}
\exitexample

\rSec1[expr.suffix]{后缀运算符}
\indextext{运算符!后缀}

\begin{bnf}{SuffixExpr}
    PrimaryExpr \br
    IndexExpr \br
    FuncCallExpr \br
    MemberAccessExpr \br
    AwaitExpr \br
    NullCheckExpr \br
    PrevNextExpr
\end{bnf}

\rSec2[expr.sub]{下标运算符}
\indextext{运算符!下标}

\begin{bnf}{IndexExpr}
    SuffixExpr \terminal{[} ExprList\bnfq \terminal{]}
\end{bnf}

\pnum
下标运算符用于对数组进行访问。$a\tcode{[}i\tcode{]}$表示数组$a$的第$i$个元素。用户自定义的下标运算符可以接受多于一个参数。

\rSec2[expr.call]{函数调用运算符}
\indextext{运算符!函数调用}

\begin{bnf}{FuncCallExpr}
    SuffixExpr \terminal{(} Arguments\bnfq \terminal{)} Block\bnfs \br
    SuffixExpr Block
\end{bnf}

\begin{bnf}{Arguments}
    UnnamedArgs \br
    NamedArgs \br
    UnnamedArgs \terminal{,} NamedArgs
\end{bnf}

\begin{bnf}{UnnamedArgs}
    Expression \br
    UnnamedArgs \terminal{,} Expression
\end{bnf}

\begin{bnf}{NamedArgs}
    Identifier \terminal{:} Expression \br
    NamedArgs \terminal{,} Identifier \terminal{:} Expression
\end{bnf}

\pnum
函数调用运算符用于调用函数。括号内的项作为参数传递给函数。

\pnum
如果函数调用运算符的左操作数形如$o\tcode{.}f$，其中$f$是一个名称且不是$o$的成员名称，则这称作\term{方法调用}。此时，$o$将作为$f$的第一个位置参数传递给函数$f$。

\pnum
函数调用运算符可以后跟一个块。这个块将作为一个匿名lambda块，创建一个lambda表达式并作为函数的最后一个位置参数传递给函数。若此时函数没有任何其他参数，则函数调用的小括号可以省略。

\rSec2[expr.member]{成员访问运算符}
\indextext{运算符!成员访问}

\begin{bnf}{MemberAccessExpr}
    SuffixExpr \terminal{.} UnqualID \br
    SuffixExpr \terminal{.} IntegerLiteral \br
    SuffixExpr \terminal{.} \terminal{(} Expression \terminal{)}
\end{bnf}

\pnum
成员访问运算符用于访问对象的成员。$o\tcode{.}m$表示对象$o$的成员$m$。如果$o$没有成员$m$，若它后跟一个函数调用运算符，则作为方法调用处理；否则这是一个编译错误。

\pnum
$o\tcode{.}i$用于元组成员的访问，表示$o$的第$i$个元素。$i$必须是一个不包含前缀或后缀的十进制字面量。如果$i$大于元组的长度，这是一个编译错误。

\pnum
$o\tcode{.(}e\tcode{)}$首先对$e$求值。如果得到一个\tcode{symbol}类型的值，则对$o$进行成员访问。如果得到一个整数类型的值，则对$o$进行元组成员访问。否则，这是一个编译错误。$e$必须是常量表达式。

\rSec2[expr.await]{\tcode{await}运算符}
\indextext{运算符!await}

\begin{bnf}{AwaitExpr}
    SuffixExpr \terminal{.} \terminal{await}
\end{bnf}

\pnum
\tcode{await}运算符用于等待一个异步表达式的结果。$e\tcode{.await}$挂起当前计算，直到$e$的值可用。如果$e$的类型是$\tcode{core.Future<}T\tcode{>}$，则$e\tcode{.await}$的类型是$T$。

\rSec2[expr.null]{空值检测运算符}
\indextext{运算符!空值检测}

\begin{bnf}{NullCheckExpr}
    SuffixExpr \terminal{?} \br
    SuffixExpr \terminal{!}
\end{bnf}

\pnum
$e\tcode{?}$对$e$进行空值检测。如果$e$的值不为\tcode{nil}，则$e\tcode{?}$的值为$e$；否则，该表达式直到空值检测运算符为止的整个表达式的值为\tcode{nil}。$e$的类型必须是$T\tcode{?}$。即使空值检测运算符检测为空，表达式的其它部分仍然会被求值。

\enterexample
\begin{codeblock}
let a: int? = nil;

a + 1 // 编译错误，不存在接受\tcode{int?}和\tcode{int}的加法运算符
a? + 1 // \tcode{nil}
(a + 1)? // \tcode{nil}，多余的运算符
a? + 1 ?? 1 // $1$，\tcode{?}不会越过\tcode{??}运算符
(a? + 1) ?? 1 // 同上，但是更清晰
\end{codeblock}
\exitexample

\pnum
$e\tcode{!}$与$e\tcode{?}$类似，但它在$e$为\tcode{nil}的时候抛出\tcode{core.Exception.checkedNil}。

\pnum
如果空值检测运算符的操作数类型是$T\tcode{?}$，则整个表达式的类型为$T$。
如果空值检测运算符的左操作数不是可空类型，则空值检测运算符将被忽略。实现可以为此提出一个警告。

\rSec2[expr.prev-next]{前驱后继运算符}
\indextext{运算符!前驱后继}

\begin{bnf}{PrevNextExpr}
    SuffixExpr \terminal{+!} \br
    SuffixExpr \terminal{-!}
\end{bnf}

\pnum
$e\tcode{+!}$和$e\tcode{-!}$分别表示$e$的后继和前驱。如果$e$的类型是算数类型，$e\tcode{+!}$等价于$e+1$，$e\tcode{-!}$等价于$e-1$。

\rSec1[expr.prefix]{前缀运算符}
\indextext{运算符!前缀}

\begin{bnf}{PrefixExpr}
    SuffixExpr \br
    MathPrefixExpr \br
    NegationExpr
\end{bnf}

\rSec2[expr.prefix-math]{数学前缀运算符}
\indextext{运算符!数学前缀}

\begin{bnf}{MathPrefixExpr}
    \terminal{+} PrefixExpr \br
    \terminal{-} PrefixExpr
\end{bnf}

\pnum
前缀运算符\tcode{+}和\ \tcode{-}\ 分别表示正号和负号。其中\tcode{+}的值为其操作数的值，而\tcode{-}的值为其相反数。操作数类型必须为算术类型。

\rSec2[expr.negation]{逻辑否运算符}
\indextext{运算符!逻辑否}

\begin{bnf}{NegationExpr}
    \terminal{!} PrefixExpr
\end{bnf}

\pnum
逻辑否运算符\tcode{!}用于对布尔值取反。如果操作数为\tcode{true}，则结果为\tcode{false}；如果操作数为\tcode{false}，则结果为\tcode{true}。

\rSec2[expr.bitwise]{位取反运算符}
\indextext{运算符!位取反}

\begin{bnf}{BitwiseNegationExpr}
    \terminal{'\~} PrefixExpr
\end{bnf}

\pnum
位取反运算符\tcode{'\~}进行按位取反。操作数的类型必须是定长整数类型。

\rSec1[expr.mul]{乘法运算符}
\indextext{运算符!乘法}

\begin{bnf}{MulExpr}
    PrefixExpr \br
    MulExpr \terminal{*} PrefixExpr \br
    MulExpr \terminal{/} PrefixExpr \br
    MulExpr \terminal{\%} PrefixExpr
\end{bnf}

\pnum
运算符\tcode{*}、\tcode{/}和\tcode{\%}分别表示乘法、除法和余数。乘除法只对整数类型进行溢出检查，而不对定长整数类型和浮点类型进行。除零检测对整数类型和定长整数类型都生效。

\rSec1[expr.add]{加法运算符}
\indextext{运算符!加法}

\begin{bnf}{AddExpr}
    MulExpr \br
    AddExpr \terminal{+} MulExpr \br
    AddExpr \terminal{-} MulExpr
\end{bnf}

\pnum
运算符\tcode{+}和\ \tcode{-}\ 分别表示加法和减法。其操作必须为算术类型。加减法只对整数类型进行溢出检查，而不对定长整数类型和浮点类型进行。

\rSec1[expr.shift]{移位运算符}
\indextext{运算符!移位}

\begin{bnf}{ShiftExpr}
    AddExpr \br
    ShiftExpr \terminal{shl} AddExpr \br
    ShiftExpr \terminal{shr} AddExpr
\end{bnf}

\pnum
运算符\tcode{shl}和\tcode{shr}表示按位左移和右移。其操作数必须为定长整数类型。在同一个表达式中混合使用\tcode{shl}和\tcode{shr}是一个编译错误。

\rSec1[expr.bit]{位运算符}
\indextext{运算符!位}

\begin{bnf}{BitwiseExpr}
    ShiftExpr \br
    BitwiseExpr \terminal{'\&} ShiftExpr \br
    BitwiseExpr \terminal{'\^{}} ShiftExpr \br
    BitwiseExpr \terminal{'|} ShiftExpr
\end{bnf}

\pnum
运算符\tcode{'\&}、\tcode{'\^{}}和\tcode{'|}分别表示按位与、按位异或和按位或。其操作数必须为定长整数类型。在同一个表达式中混合使用\tcode{'\&}、\tcode{'\^{}}和\tcode{'|}是一个编译错误。

\rSec1[expr.null-coal]{空值合并运算符}
\indextext{运算符!空值合并}

\begin{bnf}{NullCoalExpr}
    BitwiseExpr \br
    NullCoalExpr \terminal{??} BitwiseExpr
\end{bnf}

\pnum
$a\tcode{??}b$首先对$a$求值，如果其结果不是\tcode{nil}，则表达式的值为$a$，且$b$不会被求值；否则表达式的值为$b$。

\pnum
如果$a$的类型不是可空类型，则这是一个编译错误。如果$a$的类型为$A\tcode{?}$，$b$的类型为$B$，则表达式的类型为$A$和$B$的公共类型。

\rSec1[expr.range]{区间运算符}
\indextext{运算符!区间}

\begin{bnf}{RangeExpr}
    NullCoalExpr \br
    NullCoalExpr \terminal{..} NullCoalExpr
    NullCoalExpr \terminal{..=} NullCoalExpr
\end{bnf}

\pnum
运算符\tcode{..}用于生成左闭右开区间。运算符\tcode{..=}用于形成闭区间。

\rSec1[expr.connect]{连接运算符}

\begin{bnf}{ConnectExpr}
    RangeExpr \br
    ConnectExpr \terminal{\~} RangeExpr
\end{bnf}

\pnum
运算符\tcode{\~}用于连接字符串或集合。其操作数的类型必须满足以下条件之一：

\begin{itemize}
    \item 两个操作数都是\tcode{string}；
    \item 一个操作数满足$\tcode{core.Sequence<}T\tcode{>}$，另一个是$T$；
    \item 两个操作数都满足$\tcode{core.Sequence<}T\tcode{>}$。
\end{itemize}

对第一种情况，结果等于将两个字符串左右连接得到的结果；对第二种情况，$x\ \tcode{\~}\ y$等于$\tcode{[}x\tcode{,}\ \tcode{...}y\tcode{]}$或$\tcode{[...}x\tcode{,}\ y\tcode{]}$，取决于哪个操作数是序列；对第三种情况，$x\ \tcode{\~}\ y$等于$\tcode{[...}x\tcode{,}\ \tcode{...}y\tcode{]}$。

\rSec1[expr.cmp-in]{比较运算符和包含运算符}

\begin{bnf}{BooleanExpr}
    RangeExpr \br
    CompareExpr \br
    IncludeExpr
\end{bnf}

\pnum
本节中的运算符的结果都是\tcode{bool}。

\rSec2[expr.compare]{比较运算符}
\indextext{运算符!比较}

\begin{bnf}{CompareExpr}
    RangeExpr \terminal{!=} RangeExpr \br
    RangeExpr \terminal{!<} RangeExpr \br
    RangeExpr \terminal{!>} RangeExpr \br
    RangeExpr \terminal{<>} RangeExpr \br
    RangeExpr \terminal{cmp} RangeExpr \br
    LessChainExpr \br
    GreaterChainExpr \br
\end{bnf}

\begin{bnf}{LessChainExpr}
    RangeExpr LessChainOperator RangeExpr \br
    LessChainExpr LessChainOperator RangeExpr \br
\end{bnf}

\begin{bnf}{LessChainOperator}[\oneof]
    < == <=
\end{bnf}

\begin{bnf}{GreaterChainExpr}
    RangeExpr GreaterChainOperator RangeExpr \br
    GreaterChainExpr GreaterChainOperator RangeExpr
\end{bnf}

\begin{bnf}{GreaterChainOperator}[\oneof]
    > == >=
\end{bnf}

\begin{align*}
a\ \tcode{==}\ b &\iff a\ \tcode{cmp}\ b = \tcode{.equal} \\
a\ \tcode{!=}\ b &\iff a\ \tcode{cmp}\ b \ne \tcode{.equal} \\
a\ \tcode{<}\ b &\iff a\ \tcode{cmp}\ b = \tcode{.less} \\
a\ \tcode{!<}\ b &\iff a\ \tcode{cmp}\ b \ne \tcode{.less} \\
a\ \tcode{>}\ b &\iff a\ \tcode{cmp}\ b = \tcode{.greater} \\
a\ \tcode{!>}\ b &\iff a\ \tcode{cmp}\ b \ne \tcode{.greater} \\
a\ \tcode{<=}\ b &\iff a\ \tcode{cmp}\ b = \tcode{.less}\ \mathrm{or} \ \tcode{.equal} \\
a\ \tcode{>=}\ b &\iff a\ \tcode{cmp}\ b = \tcode{.greater}\ \mathrm{or} \ \tcode{.equal} \\
a\ \tcode{<>}\ b &\iff a\ \tcode{cmp}\ b = \tcode{.less}\ \mathrm{or} \ \tcode{.greater}
\end{align*}

\pnum
$a\ \tcode{cmp}\ b$比较两个表达式，其结果类型为\tcode{core.Order}。其余比较运算符的结果类型为\tcode{bool}。

\pnum
\tcode{<}、\tcode{<=}和\tcode{==}可以连续使用。$a\ \tcode{<}\ b\ \tcode{<=}\ c$等价于$a\ \tcode{<}\ b\ \tcode{\&}\ b\ \tcode{<=}\ c$。\tcode{>}、\tcode{>=}和\tcode{==}也可以用类似方式混合。以其他方式在一个表达式中使用超过一个比较运算符是一个编译错误。

\pnum
$a\ \tcode{in}\ b$检测$a$是否在$b$中。$a\ \tcode{!in}\ b$检测$a$是否不在$b$中。$b$必须实现\tcode{core.Sequence}。

\rSec2[expr.include]{包含运算符}
\indextext{运算符!包含}

\begin{bnf}{IncludeExpr}
    RangeExpr \terminal{in} RangeExpr \br
    RangeExpr \terminal{!} \terminal{in} RangeExpr
\end{bnf}

\pnum
$a\ \tcode{in}\ b$检测$a$是否在$b$中。$a\ \tcode{!in}\ b$检测$a$是否不在$b$中。$b$必须实现\tcode{core.Sequence}。

\rSec1[expr.logic]{逻辑运算符}
\indextext{运算符!逻辑}

\begin{bnf}{LogicExpr}
    BooleanExpr \br
    LogicExpr \terminal{\&} BooleanExpr \br
    LogicExpr \terminal{|} BooleanExpr
\end{bnf}

\pnum
\tcode{\&}和\tcode{|}是逻辑运算符。两者的操作数都必须实现\tcode{core.Boolean}。它们都使用短路求值。在同一个表达式中混合使用两个运算符是一个编译错误。

\rSec1[expr.assign]{赋值运算符}
\indextext{运算符!赋值}

\begin{bnf}{AssignExpr}
    LogicExpr \br
    SuffixExpr \terminal{=} LogicExpr \br
    SuffixExpr \terminal{+=} LogicExpr \br
    SuffixExpr \terminal{-=} LogicExpr \br
    SuffixExpr \terminal{*=} LogicExpr \br
    SuffixExpr \terminal{/=} LogicExpr \br
    SuffixExpr \terminal{\%=} LogicExpr \br
    SuffixExpr \terminal{shl_eq} LogicExpr \br
    SuffixExpr \terminal{shr_eq} LogicExpr \br
    SuffixExpr \terminal{'\&=} LogicExpr \br
    SuffixExpr \terminal{'\^{}=} LogicExpr \br
    SuffixExpr \terminal{'|=} LogicExpr \br
    SuffixExpr \terminal{??=} LogicExpr \br
    SuffixExpr \terminal{++} \br
    SuffixExpr \terminal{--} \br
    SuffixExpr \terminal{<\~} LogicExpr \br
    LogicExpr \terminal{\~>} SuffixExpr
\end{bnf}

\pnum
赋值表达式的结果类型是\tcode{void}。

\pnum
\tcode{=}将左操作数的值更新为右操作数的值。左操作数必须是\tcode{mut}的，且右操作数必须能隐式转换到左操作数。

\pnum
复合赋值运算符\tcode{+=}、\tcode{-=}、\tcode{*=}、\tcode{/=}、\tcode{\%=}、\tcode{shl_eq}、\tcode{shr_eq}、\tcode{'\&=}、\tcode{'\^{}=}和\tcode{'|=}分别表示加、减、乘、除、取余、左移、右移、按位与、按位异或和按位或赋值。
对这些运算符而言，$a\ op\tcode{=}\ b$或$a\ op\tcode{_eq}\ b$等价于$a\ \tcode{=}\ a\ op\ b$，但$a$只被求值一次。

\pnum
自增运算符$e\tcode{++}$等价于$e\ \tcode{=}\ e\tcode{+!}$，自减运算符$e\tcode{--}$等价于$e\ \tcode{=}\ e\tcode{-!}$，但$e$只被求值一次。

\pnum
追加运算符$e\ \tcode{<\~}\ v$等价于$e\ \tcode{=}\ e\ \tcode{\~}\ v$，$v\ \tcode{\~>}\ e$等价于$e\ \tcode{=}\ v\ \tcode{\~}\ e$，但$e$只被求值一次。

\rSec1[expr.semi]{分号运算符}
\indextext{运算符!分号}

\begin{bnf}{Expression}
    AssignExpr \br
    AssignExpr \terminal{;} Expression\br
    Binding \terminal{;} Expression
\end{bnf}

$$ x \mathbin{\tcode{;}} y \rhd \omega \coloneqq y \rhd \otimes \mathrm{discard}(x)$$

\pnum
分号表达式中，分号左侧可以为一个表达式或绑定。如果分号左侧为绑定，则该绑定会被插入到当前作用域中。如果左侧为表达式，则该表达式将被求值且结果会被丢弃。在那之后，将对右侧表达式进行求值并将其值作为整个表达式的值。