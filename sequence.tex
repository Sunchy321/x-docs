%!TEX root = x.tex

\rSec0[core.seq]{序列库}
\indextext{库!序列库}

\pnum
\tcode{core.seq}库定义了序列概念，并提供了一些操作序列的函数。

\rSec1[core.seq.traits]{概念}

\indexlibrary{\idxcode{Sequence}}
\begin{itemdecl}
trait Sequence<T> {
    type Value;
    type Iterator : core.Iterator<T>;

    let size: uint;

    func iterator() -> Iterator;
}

impl<T> Sequence<T> {
    type Value = T;

    func operator$() { this.size }
}
\end{itemdecl}

\pnum
\tcode{Sequence}表示序列。

\pnum
\tcode{Sequence<T>.Value}是序列的元素类型，其始终为\tcode{T}。

\pnum
\tcode{Sequence<T>.size}是序列的大小。序列重载了\tcode{operator\$}，返回\tcode{size}。

\pnum
\tcode{Sequence<T>.Iterator}是序列的迭代器类型，其必须实现了\tcode{core.Iterator<T>}。

\indexlibrary{\idxcode{Iterator}}
\begin{itemdecl}
trait Iterator<T> {
    func next() -> T?;
}
\end{itemdecl}

\pnum
\tcode{Iterator}表示迭代器。

\pnum
\tcode{Iterator<T>.next}返回迭代器的下一个元素，如果迭代器已经到达末尾，则返回\tcode{nil}。

\rSec1[core.seq.helper]{辅助函数}

\indexlibrary{\idxcode{map}}
\begin{itemdecl}
% func map<S : Sequence<T>, T, U>(seq: S, f: func(T) -> U) -> impl Sequence<U> {
%     impl Sequence<U> {
%         type Value = U;
%         type Iterator = impl Iterator<U>;

%         let size = seq.size;

%         func iterator() -> Iterator {
%             let it = seq.iterator();
%             return impl Iterator<U> {
%                 func next() -> U? {
%                     let x = it.next();
%                     if x == nil {
%                         return nil;
%                     }
%                     return f(x!);
%                 }
%             };
%         }
%     }
% }

func map<T, U, S : Sequence>(this: S<T>, f: func(T) -> U) -> S<U> {
    return map(this, f);
}
\end{itemdecl}